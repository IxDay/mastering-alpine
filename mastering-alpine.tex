\documentclass{beamer}
\usetheme{Perso}

\usepackage[outputdir=build]{minted}
\setminted{breaklines}
\newminted{text}{frame=single}
\usemintedstyle{tango}
\graphicspath{ {images/} }

\title{Mastering Alpine Linux}
\date{\today}
\author{Maxime Vidori}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}


\begin{frame}{Alpine?}{Never heard of it...}
  What's in the box?
  \begin{itemize}
    \item \textbf{provide a package manager and a small footprint} (v3.5 \char`~4MB).
    \item Based on busybox and musl-libc.
    \item Can be used as a distribution and come with a grsec kernel.
  \end{itemize}
  How can this helps me?
  \begin{itemize}
    \item Easier to understand and deploy.
    \item Force you to invest time in your system, and production
      environment.
    \item Reduce security risks by mastering your toolchain,
      \textbf{no more third party unknown containers!}
  \end{itemize}
\end{frame}

\begin{frame}{Alpine?}{musl libc}
  \begin{block}{musl}
    \textit{lightweight, fast, simple, free,} and strives to be
    \textit{correct} in the sense of standards-conformance and safety.
    \end{block}
  \begin{itemize}
    \item Replacement for the \textbf{glibc}, works most of the time.
    \item \textbf{\char`~600KB} vs \textbf{\char`~8MB} for complete .so set.
    \item Some softwares will not compile (I am looking at you \textbf{systemd}).
  \item You can still install it, but this is crappy and not
      recommended outside a chroot (see the documentation).
  \end{itemize}
\end{frame}

\begin{frame}{Alpine?}{busybox}
  \begin{block}{busybox}
    The Swiss Army knife of Embedded Linux
  \end{block}
  \begin{itemize}
    \item Simple binary with minimal versions of common UNIX utilities
      (rm, ls, ...).
    \item Minimal size (\textbf{\char`~2MB})
    \item Primarily designed as a recovery tool.
    \item Used by major projects such as Debian for the installation.
  \end{itemize}
\end{frame}

\begin{frame}
    \LARGE APK!
\end{frame}

\begin{frame}{When not to use it}
  \begin{itemize}
    \item The use of \textit{musl-libc} as the core library can cause some
      dependencies to not build.
    \item When building big images the small footprint is no longer an advantage
      (cross compiler can be really huge).
    \item Package library is not exhaustive (10GB big),
      this is not a debian distribution,
      if a lot of dependencies are involved do not use it.
  \end{itemize}
\end{frame}

\begin{frame}{Tooling}{}
  \begin{itemize}
    \item Busybox does not provide a package manager.
    \item Debian repo is more than \textbf{200GB}, packaging is hard and can become messy.
    \item We need simplicity and documentation, to create infrastructure.
  \end{itemize}
  Let's build a pipeline around this to speed up our workflow.
  \flushright{\LARGE \textbf{It's all about tooling!}}
\end{frame}


\begin{frame}[fragile]{Tooling}{Build your binary}
  virtual package switch:  \mintinline{shell}{apk add -t virtual} \\
  build container \textbf{\char`~200MB}$\,\to\,$prod container
  \textbf{\char`~11MB}

  \begin{minted}{docker}
FROM alpine:3.4
RUN apk add --no-cache -t build-dependencies git... \
  && git clone ... \
  && go build -ldflags '-w -s' ... \
  && apk del build-dependencies
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Tooling}{Build your mirror}

  \begin{block}{Murphy's law}
    Anything that can go wrong will go wrong.
  \end{block}

    \begin{itemize}
      \item Small footprint (\char`~5GB)
      \item Rapid builds, offline builds
      \item Push your custom package
  \end{itemize}

  Also easy to setup, just rsync the http repo and serve it through darkhttpd!
\end{frame}

\begin{frame}[fragile]{Tooling}{Build your package}
  Will you recompile your dependencies at the worst moment?
  \flushright{\textbf{(no, you won't!)}}
  \\
  \begin{itemize}

    \item Apline package description file is based on Gentoo Linux \textbf{ebuilds},
      an easy way to package is to check Archlinux AUR for examples.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Tooling}{Build your image}
  \begin{itemize}
    \item Build your image \\ \mintinline{text}{docker build -t my-alpine:1.0 .}
      \begin{minted}{docker}
FROM alpine:3.5
RUN echo "http://${DOCKER_BRIDGE_IP}:8080" > "/etc/apk/repositories"
ADD repo-key.rsa.pub /etc/apk/keys
      \end{minted}
    \item Start your mirror \\
      \mintinline{shell}{docker run -p "8080:8080" alpine-mirror}
    \item Use your pipeline!
      \begin{minted}{docker}
FROM my-alpine:1.0
RUN apk add --no-cache -t dependencies hello ...
      \end{minted}

  \end{itemize}
  \flushright{Just use \textbf{minikube} or \textbf{compose}!}

\end{frame}

\begin{frame}{Demo!}
  \LARGE \textbf{... What could possibly go wrong?}
\end{frame}

\begin{frame}{Conclusion}
  \quote{
    If you think "performance" is just CPU cycles, you're very wrong.
	}{Linus Torvald}
  \quote{
    If all you have is a hammer, everything looks like a nail.
  }{Abraham Maslow}

  \begin{itemize}
    \item When building containers, think size, think network, think build time.
    \item You don't always need a full pipeline.
    \item Before starting new tools, look at what already exists.
  \end{itemize}

GITHUB!
\end{frame}


\end{document}
